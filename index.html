<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tier List MLBB</title>
  <link rel="stylesheet" href="css/estilo.css">
</head>
<body>
  <h1>Tier List - Mobile Legends</h1>
  <label for="rank">Rank:</label>
  <select id="rank">
    <option value="mythic">Mythic</option>
    <option value="legend">Legend</option>
    <option value="epic">Epic</option>
    <option value="grandmaster">Grandmaster</option>
    <option value="master">Master</option>
    <option value="elite">Elite</option>
    <option value="warrior">Warrior</option>
  </select>
  <label for="days">Dias:</label>
  <select id="days">
    <option value="1">1</option>
    <option value="3">3</option>
    <option value="7" selected>7</option>
    <option value="15">15</option>
    <option value="30">30</option>
  </select>

  <div id="filter-section">
    <h2>Filtrar por Função e Rota</h2>
    <label for="role">Função:</label>
    <select id="role">
      <option value="">Todas</option>
      <option value="mage">Mage</option>
      <option value="marksman">Marksman</option>
      <option value="tank">Tank</option>
      <option value="assassin">Assassin</option>
      <option value="fighter">Fighter</option>
      <option value="support">Support</option>
    </select>
    <label for="lane">Rota:</label>
    <select id="lane">
      <option value="">Todas</option>
      <option value="mid">Mid</option>
      <option value="gold">Gold</option>
      <option value="exp">EXP</option>
      <option value="jungle">Jungle</option>
      <option value="roam">Roam</option>
    </select>
  </div>
  <div id="loading">
    <span>Carregando</span>
    <span class="lds-ellipsis">
      <div></div><div></div><div></div><div></div>
    </span>
  </div>
  <div class="tier-box tier-ss">
    <div class="tier-label ss">SS</div>
    <div id="tier-ss" class="tier-container"></div>
  </div>
  <div class="tier-box tier-s">
    <div class="tier-label s">S</div>
    <div id="tier-s" class="tier-container"></div>
  </div>
  <div class="tier-box tier-a">
    <div class="tier-label a">A</div>
    <div id="tier-a" class="tier-container"></div>
  </div>
  <script>
    // ====== Cache local (sessão) =======
    const HERO_MAP_CACHE_KEY = 'mlbb_hero_map';
    const HERO_POSITION_CACHE_KEY = 'mlbb_hero_positions';

    let heroIdToName = null;
    let heroNameToId = null;
    let heroExtraInfo = null;
    let tierCards = [];
    let tierRecords = [];

    // Cache fetch helper
    function fetchWithCache(url, key, expireMinutes = 120) {
      const now = Date.now();
      const cached = sessionStorage.getItem(key);
      if (cached) {
        try {
          const obj = JSON.parse(cached);
          if (now - obj.time < expireMinutes * 60 * 1000) {
            return Promise.resolve(obj.data);
          }
        } catch (e) {}
      }
      return fetch(url)
        .then(res => res.json())
        .then(json => {
          sessionStorage.setItem(key, JSON.stringify({time: now, data: json}));
          return json;
        });
    }

    // Carrega o dicionário de id para nome UMA VEZ (cache sessão)
    function fetchHeroMap() {
      if (heroIdToName && heroNameToId) return Promise.resolve();
      return fetchWithCache(
        'https://mlbb-proxy.vercel.app/api/hero-list',
        HERO_MAP_CACHE_KEY
      ).then(map => {
        heroIdToName = map;
        heroNameToId = {};
        Object.entries(map).forEach(([id, name]) => {
          heroNameToId[name] = id;
        });
      });
    }

    // Carrega info de posição UMA VEZ (cache sessão)
    function fetchAllHeroPositions() {
      if (heroExtraInfo) return Promise.resolve();
      return fetchWithCache(
        'https://mlbb-proxy.vercel.app/api/hero-position?role=all&lane=all&size=127&index=1',
        HERO_POSITION_CACHE_KEY
      ).then(json => {
        heroExtraInfo = {};
        (json.data.records || []).forEach(entry => {
          const heroData = entry.data;
          heroExtraInfo[String(heroData.hero_id)] = {
            role: (heroData.hero && heroData.hero.data && heroData.hero.data.sortid && heroData.hero.data.sortid.length && heroData.hero.data.sortid[0] && heroData.hero.data.sortid[0].data && heroData.hero.data.sortid[0].data.sort_title) ? heroData.hero.data.sortid[0].data.sort_title.toLowerCase() : "",
            roadsort: (heroData.hero && heroData.hero.data && heroData.hero.data.roadsort) ? heroData.hero.data.roadsort : []
          };
        });
      });
    }

    // Mostra/oculta animação de loading
    function showLoading(show=true) {
      document.getElementById('loading').style.display = show ? '' : 'none';
    }

    // Monta a tierlist
    function carregarTierList() {
      showLoading(true);

      const rank = document.getElementById('rank').value;
      const days = document.getElementById('days').value;
      const url = `https://mlbb-proxy.vercel.app/api/hero-rank?source=rank&days=${days}&rank=${rank}&size=130&sort_field=win_rate&sort_order=desc`;

      document.getElementById('tier-ss').innerHTML = '';
      document.getElementById('tier-s').innerHTML = '';
      document.getElementById('tier-a').innerHTML = '';
      tierCards = [];
      tierRecords = [];

      Promise.all([
        fetchHeroMap(),
        fetchAllHeroPositions(),
        fetch(url).then(res => res.json())
      ])
      .then(([_, __, json]) => {
        const records = json.data.records || [];
        tierRecords = records;

        records.forEach(entry => {
          const hero = entry.data.main_hero.data;
          const winRate = (entry.data.main_hero_win_rate * 100).toFixed(1);

          // Descobre o id do herói pelo nome
          const heroId = heroNameToId[hero.name];
          const info = heroExtraInfo[heroId] || {};
          const role = info.role || '';
          let roadsortTitles = [];
          let iconCount = 0;
          let roadsortHtml = '';

          if (Array.isArray(info.roadsort) && info.roadsort.length > 0) {
            roadsortTitles = info.roadsort.map(rs => (rs.data && rs.data.road_sort_title) ? rs.data.road_sort_title : '').filter(Boolean);
            iconCount = info.roadsort.length;
            roadsortHtml = info.roadsort.map(rs => {
              const data = rs.data || {};
              return data.road_sort_icon
                ? `<span class="hero-route"><img src="${data.road_sort_icon}" alt="" title="${data.road_sort_title}"></span>`
                : '';
            }).join('');
          } else {
            // Se não tem rota (ex: Miya), mostra div vazia para alinhamento
            iconCount = 0;
            roadsortHtml = '';
          }

          const el = document.createElement('div');
          el.className = 'card';
          el.setAttribute('data-role', role);
          el.setAttribute('data-routes', roadsortTitles.join('|').toLowerCase());
          el.setAttribute('data-id', heroId || '');
          el.setAttribute('data-name', hero.name);

          // Adiciona a classe single quando só tem 1 rota
          if (iconCount === 1) {
            el.innerHTML = `
              <img src="${hero.head}" alt="${hero.name}">
              <div class="hero-name">${hero.name}</div>
              <div class="hero-meta">${winRate}% WR</div>
              <div class="hero-routes single">${roadsortHtml}</div>
            `;
          } else if (iconCount > 1) {
            el.innerHTML = `
              <img src="${hero.head}" alt="${hero.name}">
              <div class="hero-name">${hero.name}</div>
              <div class="hero-meta">${winRate}% WR</div>
              <div class="hero-routes">${roadsortHtml}</div>
            `;
          } else {
            // Se não tem rota, mostra div vazia para alinhamento
            el.innerHTML = `
              <img src="${hero.head}" alt="${hero.name}">
              <div class="hero-name">${hero.name}</div>
              <div class="hero-meta">${winRate}% WR</div>
              <div class="hero-routes" style="height:21px"></div>
            `;
          }

          tierCards.push(el);

          if (winRate >= 54) {
            document.getElementById('tier-ss').appendChild(el);
          } else if (winRate >= 51) {
            document.getElementById('tier-s').appendChild(el);
          } else {
            document.getElementById('tier-a').appendChild(el);
          }
        });
        showLoading(false);
      })
      .catch(err => {
        console.error("Erro ao carregar tier list:", err);
        showLoading(false);
      });
    }

    // Filtra os cards já existentes na tierlist
    function filtrarTierList() {
      const role = document.getElementById('role').value.toLowerCase();
      const lane = document.getElementById('lane').value.toLowerCase();

      document.querySelectorAll('.tier-container .card').forEach(card => {
        const heroRole = (card.getAttribute('data-role') || '').toLowerCase();
        const heroRoutes = (card.getAttribute('data-routes') || '').toLowerCase();
        let mostra = true;
        if (role && !heroRole.includes(role)) mostra = false;
        if (lane && !heroRoutes.includes(lane)) mostra = false;
        card.classList.toggle('hidden', !mostra);
      });
    }

    // Eventos automáticos de filtro/update
    document.addEventListener('DOMContentLoaded', function () {
      carregarTierList();

      document.getElementById('rank').addEventListener('change', carregarTierList);
      document.getElementById('days').addEventListener('change', carregarTierList);
      document.getElementById('role').addEventListener('change', filtrarTierList);
      document.getElementById('lane').addEventListener('change', filtrarTierList);
    });
  </script>
</body>
</html>
